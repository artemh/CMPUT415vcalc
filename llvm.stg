group llvm;

program(container, decl, stat) ::= <<
; ModuleID = '<filename()>'

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; This prints integer %d followed by \n followed by string termination symbol
@.str.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.int.raw = private unnamed_addr constant [4 x i8] c"%d\20\00", align 1
@.str.lbrack = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.rbrack = private unnamed_addr constant [4 x i8] c" ]\0A\00", align 1
@.str.rerror = private unnamed_addr constant [54 x i8] c"Range lower bound must be less than the upper bound.\0A\00", align 1
<decl:{d|<d>}>

%struct.vecType = type { i32, i32, \<32 x i32\>* }

define void @.printVec(%struct.vecType* %ptr) nounwind uwtable {
	%print_num_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
	%print_num = load i32* %print_num_ptr, align 4

	; need to loop over the array and print the values
    
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 0, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4
    
    br label %print.for.range.begin
	print.for.range.begin:
	%lc = load i32* %lc_ptr
	%offset = load i32* %offset_ptr
	
	%compar = icmp ugt i32 %lc, %print_num
	br i1 %compar, label %print.for.range.done, label %print.for.range.next
	print.for.range.next:
	
	; get a pointer to the list of arrays
	%ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
	; load the list of arrays
	%array_2 = load \<32 x i32\>** %ar_ptr, align 8 
	
	; need to figure out which block the item is in
	%block_num = udiv i32 %offset, 32
	; need to figure out which index in that block the item is in
	%index_block = urem i32 %offset, 32
	
	%arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
	%1 = load \<32 x i32\>* %arrayidx, align 128
	%value = extractelement \<32 x i32\> %1, i32 %index_block
	
	;%printerVec1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int.raw, i32 0, i32 0), i32 %block_num)
	;%printerVec2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int.raw, i32 0, i32 0), i32 %index_block)
	%printerVec3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int.raw, i32 0, i32 0), i32 %value)
	
	; %printer2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 11)
	
	%new_lc = add i32 %lc, 1 
	store i32 %new_lc, i32* %lc_ptr, align 4
	%new_offset = add i32 %offset, 1
	store i32 %new_offset, i32* %offset_ptr, align 4
	
	br label %print.for.range.begin
	print.for.range.done:
	
	ret void
}

define void @.range(i32 %lbound, i32 %ubound, %struct.vecType* %ptr) nounwind uwtable {
    ; calculate the number of elements 
    %num_elem_temp = sub i32 %ubound, %lbound
    %num_elem = add i32 %num_elem_temp, 1
    ; calculate the number of 32-element segments required 
    %temp = udiv i32 %num_elem, 32
    ; add 1 since division rounds down
    %blocks = add i32 %temp, 1
    ; calculate the number of elements in the last segment 
    %last_block_elements = urem i32 %num_elem, 32 
    
    ; need this because calloc expects i64
    %blocks64 = zext i32 %blocks to i64 
	; allocate memory for the array
	%call = call noalias i8* @calloc(i64 %blocks64, i64 128)
	%array = bitcast i8* %call to \<32 x i32\>*
    ; get array ptr
    %data = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    
    ; plug in the integer values 
    %1 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
    store i32 %num_elem, i32* %1, align 4
    %2 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 1
    store i32 %blocks, i32* %2, align 4
    
    ; need to loop over the array and set the values
    
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 %lbound, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4
    
    br label %for.range.begin
	for.range.begin:
	%lc = load i32* %lc_ptr
	%offset = load i32* %offset_ptr
	
	%compar = icmp ugt i32 %lc, %ubound
	br i1 %compar, label %for.range.done, label %for.range.next
	for.range.next:
	
	; get a pointer to the list of arrays
	%ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
	; load the list of arrays
	%array_2 = load \<32 x i32\>** %ar_ptr, align 8 
	
	; need to figure out which block the item is in
	%block_num = udiv i32 %offset, 32
	; need to figure out which index in that block the item is in
	%index_block = urem i32 %offset, 32
	
	; get the required array address
	%arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
	
	; get the actual array
	%3 = load \<32 x i32\>* %arrayidx, align 128
	
	%insert = insertelement \<32 x i32\> %3, i32 %lc, i32 %index_block
	
	;need to put it back, not sure how yet
	store \<32 x i32\> %3, \<32 x i32\>* %arrayidx, align 128
	
	; %printer2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 11)
	
	%new_lc = add i32 %lc, 1 
	store i32 %new_lc, i32* %lc_ptr, align 4
	%new_offset = add i32 %offset, 1
	store i32 %new_offset, i32* %offset_ptr, align 4
	
	br label %for.range.begin
	for.range.done:
    ; print statement for debugging, print 11
    %printer = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 11)
    ret void
}


define i32 @main() nounwind uwtable {
  <container.intNames:{x|<initInt(name=(x), counters = container.counters, templates=container.inits)>}>
  <container.vecNames:{x|<initVec(name=(x), counters = container.counters, templates=container.inits)>}>
  <stat:{s|<s>}>
	
  br label %quit.label
  quit.label:
  	ret i32 0
}

declare i32 @printf(i8*, ...)
declare noalias i8* @calloc(i64, i64)
>>

declInt(name) ::= <<
@<name> = global i32 0, align 4

>>

declVec() ::= <<

>>

initInt(name, counters, templates) ::= <<
<templates.(name)>
store i32 %<counters.(name)>, i32* @<name>, align 4

>>

if(counter, if_counter, expr_counter, expr, b) ::= <<
<expr>
%<counter> = icmp ne i32 %<expr_counter>, 0
br i1 %<counter>, label %if.true<if_counter>, label %if.done<if_counter>
if.true<if_counter>:
  <b>
  br label %if.done<if_counter>
if.done<if_counter>:

>>

loop(counter, loop_counter, expr_counter, expr, b) ::= <<
br label %loop.begin<loop_counter>
loop.begin<loop_counter>:
<expr>
%<counter> = icmp eq i32 %<expr_counter>, 0
br i1 %<counter>, label %loop.done<loop_counter>, label %loop.true<loop_counter>
loop.true<loop_counter>:
  <b>
  br label %loop.begin<loop_counter>
loop.done<loop_counter>:

>>

assignInt(name, expr_counter, expr) ::= <<
<expr>
store i32 %<expr_counter>, i32* <name>, align 4

>>

printVec(counter, expr_counter, expr) ::= <<
<expr>
%lbrack<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str.lbrack, i32 0, i32 0))
call void @.printVec(%struct.vecType* %<expr_counter>)
%rbrack<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.rbrack, i32 0, i32 0))

>>

printInt(counter, expr_counter, expr) ::= <<
<expr>
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 <expr_counter>)

>>

block(s) ::= <<
<s:{x|<x>}>
>>

eqIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp eq i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

neIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ne i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

ltIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ult i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

gtIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ugt i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

addIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = add i32 %<lhs_counter>, %<rhs_counter>

>>

subIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = sub i32 %<lhs_counter>, %<rhs_counter>

>>

mulIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = mul i32 %<lhs_counter>, %<rhs_counter>

>>

divIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = udiv i32 %<lhs_counter>, %<rhs_counter>

>>

range(c1, c2, rc, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ule i32 %<lhs_counter>, %<rhs_counter>
br i1 %<c1>, label %range.valid<rc>, label %range.invalid<rc>
range.valid<rc>:
    %<c2> = alloca %struct.vecType, align 8
	call void @.range(i32 %<lhs_counter>, i32 %<rhs_counter>, %struct.vecType* %<c2>)
	br label %range.done<rc>
range.invalid<rc>:
	%rerror<rc> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([54 x i8]* @.str.rerror, i32 0, i32 0))
	br label %quit.label
range.done<rc>:

>>

varnum(counter, name) ::= <<
%<counter> = load i32* <name>
>>

integer(counter, value) ::= <<
%<counter> = add i32 <value>, 0
>>

write(input) ::= <<
<input>
>>