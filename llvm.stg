group llvm;

program(container, decl, stat) ::= <<
; ModuleID = '<filename>'

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; This prints integer %d followed by \n followed by string termination symbol
@.str.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.lbrack = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.rbrack = private unnamed_addr constant [3 x i8] c" ]\00", align 1
<decl:{d|<d>}>

define i32 @main() nounwind uwtable {
  <container.intNames:{x|<initInt(name=(x), counters = container.counters, templates=container.inits)>}>
  <container.vecNames:{x|<initVec(name=(x), counters = container.counters, templates=container.inits)>}>
  <stat:{s|<s>}>

  ret i32 0
}

declare i32 @printf(i8*, ...)

>>

declInt(name) ::= <<
@<name> = global i32 0, align 4

>>

initInt(name, counters, templates) ::= <<
<templates.(name)>
store i32 %<counters.(name)>, i32* @<name>, align 4

>>

if(counter, if_counter, expr_counter, expr, b) ::= <<
<expr>
%<counter> = icmp ne i32 %<expr_counter>, 0
br i1 %<counter>, label %if.true<if_counter>, label %if.done<if_counter>
if.true<if_counter>:
  <b>
  br label %if.done<if_counter>
if.done<if_counter>:

>>

loop(counter, loop_counter, expr_counter, expr, b) ::= <<
br label %loop.begin<loop_counter>
loop.begin<loop_counter>:
<expr>
%<counter> = icmp eq i32 %<expr_counter>, 0
br i1 %<counter>, label %loop.done<loop_counter>, label %loop.true<loop_counter>
loop.true<loop_counter>:
  <b>
  br label %loop.begin<loop_counter>
loop.done<loop_counter>:

>>

assignInt(name, expr_counter, expr) ::= <<
<expr>
store i32 %<expr_counter>, i32* <name>, align 4

>>

print(counter, expr_counter, expr) ::= <<
<expr>
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %<expr_counter>)

>>

block(s) ::= <<
<s:{x|<x>}>
>>

eqIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp eq i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

neIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ne i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

ltIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ult i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

gtIntInt(c1, c2, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ugt i32 %<lhs_counter>, %<rhs_counter>
%<c2> = zext i1 %<c1> to i32

>>

addIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = add i32 %<lhs_counter>, %<rhs_counter>

>>

subIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = sub i32 %<lhs_counter>, %<rhs_counter>

>>

mulIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = mul i32 %<lhs_counter>, %<rhs_counter>

>>

divIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = udiv i32 %<lhs_counter>, %<rhs_counter>

>>

varnum(counter, name) ::= <<
%<counter> = load i32* <name>
>>

integer(counter, value) ::= <<
%<counter> = add i32 <value>, 0
>>
