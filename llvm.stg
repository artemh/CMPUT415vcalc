group llvm;

program(container, decl, stat) ::= <<
; ModuleID = '<filename()>'

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.vecType = type { i32, i32, \<32 x i32\>* }

; This prints integer %d followed by \n followed by string termination symbol
@.str.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.int.raw = private unnamed_addr constant [4 x i8] c"%d\20\00", align 1
@.str.lbrack = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.rbrack = private unnamed_addr constant [3 x i8] c"]\0A\00", align 1
@.str.rerror = private unnamed_addr constant [54 x i8] c"Range lower bound must be less than the upper bound.\0A\00", align 1
<decl:{d|<d>}>


define void @.printVec(%struct.vecType* %ptr) nounwind uwtable {
	%print_num_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
	%print_num = load i32* %print_num_ptr, align 4

	; need to loop over the array and print the values
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 0, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4

        br label %print.for.range.begin
	print.for.range.begin:
    	%lc = load i32* %lc_ptr
    	%offset = load i32* %offset_ptr
    	%compar = icmp ugt i32 %lc, %print_num
    	br i1 %compar, label %print.for.range.done, label %print.for.range.next
	print.for.range.next:
    	; get a pointer to the list of arrays
    	%ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
    	; load the list of arrays
    	%array_2 = load \<32 x i32\>** %ar_ptr, align 8
    	; need to figure out which block the item is in
    	%block_num = udiv i32 %offset, 32
    	; need to figure out which index in that block the item is in
    	%index_block = urem i32 %offset, 32
    	%arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
    	%1 = load \<32 x i32\>* %arrayidx
    	%value = extractelement \<32 x i32\> %1, i32 %index_block
    	%printerVec3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int.raw, i32 0, i32 0), i32 %value)
    	%new_lc = add i32 %lc, 1
    	store i32 %new_lc, i32* %lc_ptr, align 4
    	%new_offset = add i32 %offset, 1
    	store i32 %new_offset, i32* %offset_ptr, align 4
    	br label %print.for.range.begin
	print.for.range.done:
	ret void
}

define void @.indexInt(%struct.vecType* %source, i32 %index, i32* %dest) nounwind uwtable {
    %sizePtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 0
    %size = load i32* %sizePtr, align 4
    ; get a pointer to the list of arrays
    %ar_ptr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 2
    ; load the list of arrays
    %array = load \<32 x i32\>** %ar_ptr, align 8
    %block_num = udiv i32 %index, 32
    ; need to figure out which index in that block the item is in
    %index_block = urem i32 %index, 32
    %arrayidx = getelementptr inbounds \<32 x i32\>* %array, i32 %block_num
    %vector = load \<32 x i32\>* %arrayidx
    %value = extractelement \<32 x i32\> %vector, i32 %index_block
    
    store i32 %value, i32* %dest, align 4
    ret void
}

define void @.indexVec(%struct.vecType* %source, %struct.vecType* %index, %struct.vecType* %dest) nounwind uwtable {
    %sourceSizePtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 0
    %sourceSize = load i32* %sourceSizePtr, align 4
    %indexSizePtr = getelementptr inbounds %struct.vecType* %index, i32 0, i32 0
    %indexSize = load i32* %indexSizePtr, align 4
    
    ;Allocate memory
    %indexBlkPtr = getelementptr inbounds %struct.vecType* %index, i32 0, i32 1
    %indexBlk = load i32* %indexBlkPtr, align 4
    ; need this because calloc expects i64
    %blocks64 = sext i32 %indexBlk to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*
    
    %src_ar_ptr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 2
    %ind_ar_ptr = getelementptr inbounds %struct.vecType* %index, i32 0, i32 2

    %src_array = load \<32 x i32\>** %src_ar_ptr, align 8
    %ind_array = load \<32 x i32\>** %ind_ar_ptr, align 8
    
    ;set up the loop
    %lc_ptr = alloca i32
    store i32 0, i32* %lc_ptr, align 4
    ;start the loop    
    br label %indexvec.begin
    indexvec.begin:
        %lc = load i32* %lc_ptr
        %compar = icmp ule i32 %lc, %indexSize
        
        br i1 %compar, label %indexvec.next, label %indexvec.done
    indexvec.next:
        ; do stuff        
        ; get the index element
        ; need to figure out which block the item is in
        %ind_block_num = udiv i32 %lc, 32
        ; need to figure out which index in that block the item is in
        %ind_index_block = urem i32 %lc, 32
        %ind_arrayidx = getelementptr inbounds \<32 x i32\>* %ind_array, i32 %ind_block_num
        %index_ar = load \<32 x i32\>* %ind_arrayidx
        %index_value = extractelement \<32 x i32\> %index_ar, i32 %ind_index_block
        ; see if out of bounds
        %lzero = icmp slt i32 %index_value, 0
        br i1 %lzero, label %indexvec.zero, label %indexvec.next2
        
    indexvec.next2:
        %gsize = icmp ugt i32 %index_value, %sourceSize    
        br i1 %gsize, label %indexvec.zero, label %indexvec.next3
        
    indexvec.next3:
        ; not zero, get the value  
        %iprinter5 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 42222)  
        %iprinter6 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %index_value) 
        ; need to figure out which block the item is in
        %src_block_num = udiv i32 %index_value, 32
        ; need to figure out which index in that block the item is in
        %src_index_block = urem i32 %index_value, 32
        
        %src_arrayidx = getelementptr inbounds \<32 x i32\>* %src_array, i32 %src_block_num
        %src_ar = load \<32 x i32\>* %src_arrayidx
        %src_value = extractelement \<32 x i32\> %src_ar, i32 %src_index_block
        %iprinter61 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %src_value) 
        
        %dest_arrayidx = getelementptr inbounds \<32 x i32\>* %array, i32 %ind_block_num
        %dest_ar = load \<32 x i32\>* %dest_arrayidx
        %insert_value = insertelement \<32 x i32\> %dest_ar, i32 %src_value, i32 %ind_index_block
        store \<32 x i32\> %insert_value, \<32 x i32\>* %dest_arrayidx
        br label %indexvec.step
    indexvec.zero:    
        ; set result to 0
        %dest_arrayidx0 = getelementptr inbounds \<32 x i32\>* %array, i32 %ind_block_num
        %dest_ar0 = load \<32 x i32\>* %dest_arrayidx0
        %insert_zero = insertelement \<32 x i32\> %dest_ar0, i32 0, i32 %ind_index_block
        store \<32 x i32\> %insert_zero, \<32 x i32\>* %dest_arrayidx
        br label %indexvec.step
    indexvec.step:    
        %new_lc = add i32 %lc, 1
        store i32 %new_lc, i32* %lc_ptr, align 4
        br label %indexvec.begin
        
    indexvec.done:    
    ;set the integer values
    %indexNumPtr = getelementptr inbounds %struct.vecType* %index, i32 0, i32 0
    %destNumPtr = getelementptr inbounds %struct.vecType* %dest, i32 0, i32 0
    %indexNum = load i32* %indexNumPtr, align 4
    store i32 %indexNum, i32* %destNumPtr, align 4
    
    %indexBlkPtr2 = getelementptr inbounds %struct.vecType* %index, i32 0, i32 1
    %destBlkPtr = getelementptr inbounds %struct.vecType* %dest, i32 0, i32 1
    %indexBlk2 = load i32* %indexBlkPtr2, align 4    
    store i32 %indexBlk2, i32* %destBlkPtr, align 4
    
    ;set the array
    %data = getelementptr inbounds %struct.vecType* %dest, i32 0, i32 2
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    
    ret void
}

define void @.mulVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
        %lc = load i32* %lc_ptra
        %compar3 = icmp slt i32 %lc, %Size
        br i1 %compar3, label %add.loop, label %add.done

    add.loop:
        ;perform subtraction
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
        %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
        %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

        %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
        %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

        %vector_result = mul nsw \<32 x i32\> %vector_lhs, %vector_rhs

        store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptra, align 4
        br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.subVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
        %lc = load i32* %lc_ptra
        %compar3 = icmp slt i32 %lc, %Size
        br i1 %compar3, label %add.loop, label %add.done

    add.loop:
        ;perform subtraction
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
        %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
        %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

        %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
        %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

        %vector_result = sub nsw \<32 x i32\> %vector_lhs, %vector_rhs

        store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptra, align 4
        br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.divVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
        %lc = load i32* %lc_ptra
        %compar3 = icmp slt i32 %lc, %Size
        br i1 %compar3, label %add.loop, label %add.done

    add.loop:
        ;perform subtraction
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
        %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
        %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

        %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
        %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

        %vector_result = sdiv \<32 x i32\> %vector_lhs, %vector_rhs

        store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptra, align 4
        br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

; This function assumes same size
define void @.addVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
        %lc = load i32* %lc_ptra
        %compar3 = icmp slt i32 %lc, %Size
        br i1 %compar3, label %add.loop, label %add.done

    add.loop:
        ;perform addition
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
        %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
        %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

        %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
        %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

        %vector_result = add \<32 x i32\> %vector_lhs, %vector_rhs

        store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptra, align 4
        br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.lessVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result, i32 %numOps) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over number of elements and compare
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %eq.loop.begin

    eq.loop.begin:
        %lc = load i32* %lc_ptr
        %compar3 = icmp sle i32 %lc, %numOps
        br i1 %compar3, label %eq.loop, label %eq.done

    eq.loop:
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        ; need to get block number which to load
        %blocknum = udiv i32 %lc, 32
        %index = urem i32 %lc, 32

        ; need to compare indeces and set corresponding result element accordingly
        %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %blocknum
        %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %blocknum
        %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum

        %arl = load \<32 x i32\>* %arrayidxl
        %arr = load \<32 x i32\>* %arrayidxr
        %arres = load \<32 x i32\>* %resultidx

        %valuel = extractelement \<32 x i32\> %arl, i32 %index
        %valuer = extractelement \<32 x i32\> %arr, i32 %index
        ; compare
        %eqals = icmp slt i32 %valuel, %valuer
        br i1 %eqals, label %eq.yes, label %eq.no

    eq.yes:
        ; working with %arres, plug in the 1 into arres, plug the array back in
        %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
        store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
        br label %eq.next

    eq.no:
        ; working with %arres, plug in the 0 into arres, plug the array back in
        %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
        store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
        br label %eq.next
        eq.next:

    ;increment lc
        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptr, align 4
        br label %eq.loop.begin

    eq.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}


define void @.equalsVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result, i32 %numOps) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over number of elements and compare
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %eq.loop.begin

    eq.loop.begin:
        %lc = load i32* %lc_ptr
        %compar3 = icmp sle i32 %lc, %numOps
        br i1 %compar3, label %eq.loop, label %eq.done

    eq.loop:
        %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
        %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

        ; need to get block number which to load
        %blocknum = udiv i32 %lc, 32
        %index = urem i32 %lc, 32

        ; need to compare indeces and set corresponding result element accordingly
        %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %blocknum
        %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %blocknum
        %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum

        %arl = load \<32 x i32\>* %arrayidxl
        %arr = load \<32 x i32\>* %arrayidxr
        %arres = load \<32 x i32\>* %resultidx

        %valuel = extractelement \<32 x i32\> %arl, i32 %index
        %valuer = extractelement \<32 x i32\> %arr, i32 %index
        ; compare
        %eqals = icmp eq i32 %valuel, %valuer
        br i1 %eqals, label %eq.yes, label %eq.no

    eq.yes:
        ; working with %arres, plug in the 1 into arres, plug the array back in
        %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
        store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
        br label %eq.next

    eq.no:
        ; working with %arres, plug in the 0 into arres, plug the array back in
        %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
        store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
        br label %eq.next
        eq.next:

    ;increment lc
        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptr, align 4
        br label %eq.loop.begin

    eq.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.flip(%struct.vecType* %source, %struct.vecType* %result) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over number of elements and flip
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %flip.loop.begin

    flip.loop.begin:
        %lc = load i32* %lc_ptr
        %compar = icmp sle i32 %lc, %num
        br i1 %compar, label %flip.loop, label %flip.done

    flip.loop:
        %ar_ptr_source = getelementptr inbounds %struct.vecType* %source, i32 0, i32 2
        %array_source = load \<32 x i32\>** %ar_ptr_source, align 8

        ; need to get block number which to load
        %blocknum = udiv i32 %lc, 32
        %index = urem i32 %lc, 32

        %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_source, i32 %blocknum
        %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum

        %arsource = load \<32 x i32\>* %arrayidxl
        %arres = load \<32 x i32\>* %resultidx

        %valuesource = extractelement \<32 x i32\> %arsource, i32 %index
        ; compare
        %eqals = icmp eq i32 %valuesource, 0
        br i1 %eqals, label %flip.yes, label %flip.no

    flip.yes:
        ; working with %arres, plug in the 1 into arres, plug the array back in
        %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
        store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
        br label %flip.next

    flip.no:
        ; working with %arres, plug in the 0 into arres, plug the array back in
        %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
        store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
        br label %flip.next
        flip.next:

    ;increment lc
        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptr, align 4
        br label %flip.loop.begin

    flip.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define i32 @.padVec(%struct.vecType* %lhs, %struct.vecType* %rhs, i1 %flag) nounwind uwtable {
  %lhsSizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
  %rhsSizePtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 1
  %lhsSize = load i32* %lhsSizePtr, align 4
  %rhsSize = load i32* %rhsSizePtr, align 4
  %lhsNumPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
  %rhsNumPtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 0
  %lhsNum = load i32* %lhsNumPtr, align 4
  %rhsNum = load i32* %rhsNumPtr, align 4

  %smallerSizePtr = alloca i32
  %largerSizePtr = alloca i32

  ; need to know which one is bigger
  %compar = icmp slt i32 %lhsNum, %rhsNum
  br i1 %compar, label %pad.lhs, label %pad.rhs

  pad.lhs:
    store i32 %lhsNum, i32* %smallerSizePtr, align 4
    store i32 %rhsNum, i32* %largerSizePtr, align 4
    %blocks64 = sext i32 %rhsSize to i64
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; now loop over lhs_size number of elements and copy lhs elements
    %lc_ptr = alloca i32
    store i32 0, i32* %lc_ptr, align 4
    br label %pad.lhs.begin

  pad.lhs.begin:
        %lc = load i32* %lc_ptr
        %compar3 = icmp slt i32 %lc, %lhsSize
        br i1 %compar3, label %pad.lhs.loop, label %pad.lhs.done

  pad.lhs.loop:
        %ar_ptr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
        %array_2 = load \<32 x i32\>** %ar_ptr, align 8
        %arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %lc
        %newarrayidx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc
        %array_old = load \<32 x i32\>* %arrayidx, align 8
        store \<32 x i32\> %array_old, \<32 x i32\>* %newarrayidx
        %newlc = add i32 %lc, 1
        store i32 %newlc, i32* %lc_ptr, align 4
        br label %pad.lhs.begin

  pad.lhs.done:
    %data = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ; Set integer values
    %load0 = load i32* %rhsNumPtr, align 4
    store i32 %load0, i32* %lhsNumPtr, align 4
    %load1 = load i32* %rhsSizePtr, align 4
    store i32 %load1, i32* %lhsSizePtr, align 4
    br label %pad.done

  pad.rhs:
    store i32 %lhsNum, i32* %largerSizePtr, align 4
    store i32 %rhsNum, i32* %smallerSizePtr, align 4
    br i1 %flag, label %pad.rhs.one, label %pad.rhs.zero

  pad.rhs.zero:
    store i32 %rhsNum, i32* %smallerSizePtr, align 4
    %blocks64r = sext i32 %lhsSize to i64
    %callr = call noalias i8* @calloc(i64 %blocks64r, i64 128)
    %arrayr = bitcast i8* %callr to \<32 x i32\>*

    ; now loop over lhs_size number of elements and copy lhs elements
    %lc_ptrr = alloca i32
    store i32 0, i32* %lc_ptrr, align 4
    br label %pad.rhs.begin

  pad.rhs.begin:
        %lcr = load i32* %lc_ptrr
        %compar3r = icmp slt i32 %lcr, %rhsSize
        br i1 %compar3r, label %pad.rhs.loop, label %pad.rhs.done

  pad.rhs.loop:
        %ar_ptrr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
        %array_2r = load \<32 x i32\>** %ar_ptrr, align 8
        %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_2r, i32 %lcr
        %newarrayidxr = getelementptr inbounds \<32 x i32\>* %arrayr, i32 %lcr
        %array_oldr = load \<32 x i32\>* %arrayidxr, align 8
        store \<32 x i32\> %array_oldr, \<32 x i32\>* %newarrayidxr
        %newlcr = add i32 %lcr, 1
        store i32 %newlcr, i32* %lc_ptrr, align 4
        br label %pad.rhs.begin

  pad.rhs.done:
    %datar = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    store \<32 x i32\>* %arrayr, \<32 x i32\>** %datar, align 8
    ; Set integer values
    %load0r = load i32* %lhsNumPtr, align 4
    store i32 %load0r, i32* %rhsNumPtr, align 4
    %load1r = load i32* %lhsSizePtr, align 4
    store i32 %load1r, i32* %rhsSizePtr, align 4
    br label %pad.done.done

  pad.done:
    br i1 %flag, label %pad.rhs.one, label %pad.done.done

  pad.rhs.one:
    %largerSize = load i32* %largerSizePtr, align 4
    %blocksr32 = udiv i32 %largerSize, 32
    %blocksr321 = add i32 %blocksr32, 1
    %blocks64r1 = sext i32 %blocksr321 to i64
    %callr1 = call noalias i8* @calloc(i64 %blocks64r1, i64 128)
    %arrayr1 = bitcast i8* %callr1 to \<32 x i32\>*
    %denum_num_ptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 0
    %denum_blk_ptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 1
    %denum_num = load i32* %denum_num_ptr, align 4
    %denum_blk = load i32* %denum_blk_ptr, align 4
    %oldSize = load i32* %denum_num_ptr, align 4
    %newSize = add i32 %largerSize, 0
    %denumdataptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %denumdata = load \<32 x i32\>** %denumdataptr, align 8
    %d_lc_ptr1 = alloca i32, align 4
    store i32 0, i32* %d_lc_ptr1, align 4
    br label %pad.ones1.loop.begin

  pad.ones1.loop.begin:
        %d_lc1 = load i32* %d_lc_ptr1
        %dcmp1 = icmp ule i32 %d_lc1, %oldSize
        br i1 %dcmp1, label %pad.ones1.loop, label %pad.ones1.done

  pad.ones1.loop:
        ; need to get block number which to load
        %blocknum1 = udiv i32 %d_lc1, 32
        %index1 = urem i32 %d_lc1, 32
        %arrayidxl1 = getelementptr inbounds \<32 x i32\>* %denumdata, i32 %blocknum1
        %resultidx1 = getelementptr inbounds \<32 x i32\>* %arrayr1, i32 %blocknum1
        %arsource1 = load \<32 x i32\>* %arrayidxl1
        %arres1 = load \<32 x i32\>* %resultidx1
        %valuesource = extractelement \<32 x i32\> %arsource1, i32 %index1
        %valuenew = insertelement \<32 x i32\> %arres1, i32 %valuesource, i32 %index1
        store \<32 x i32\> %valuenew, \<32 x i32\>* %resultidx1
        %newd_lc1 = add i32 %d_lc1, 1
        store i32 %newd_lc1, i32* %d_lc_ptr1, align 4
        br label %pad.ones1.loop.begin

  pad.ones1.done:
    ;second loop
    %secondLoopStart = add i32 %oldSize, 1
    %secondLoopEnd = mul i32 %blocksr321, 32
    store i32 %secondLoopStart, i32* %d_lc_ptr1, align 4
    br label %pad.ones2.loop.begin

  pad.ones2.loop.begin:
        %d_lc2 = load i32* %d_lc_ptr1
        %dcmp2 = icmp ule i32 %d_lc2, %secondLoopEnd
        br i1 %dcmp2, label %pad.ones2.loop, label %pad.ones2.done

  pad.ones2.loop:
        ; need to get block number which to load
        %blocknum2 = udiv i32 %d_lc2, 32
        %index2 = urem i32 %d_lc2, 32
        %resultidx2 = getelementptr inbounds \<32 x i32\>* %arrayr1, i32 %blocknum2
        %arres2 = load \<32 x i32\>* %resultidx2
        %valuenew2 = insertelement \<32 x i32\> %arres2, i32 1, i32 %index2
        store \<32 x i32\> %valuenew2, \<32 x i32\>* %resultidx2
        %newd_lc2 = add i32 %d_lc2, 1
        store i32 %newd_lc2, i32* %d_lc_ptr1, align 4
        br label %pad.ones2.loop.begin

  pad.ones2.done:
    %datar2 = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    store \<32 x i32\>* %arrayr1, \<32 x i32\>** %datar2, align 8
    ; Set integer values
    %rnPtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 0
    %rbPtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 1
    store i32 %newSize, i32* %rnPtr, align 4
    %blocksr2i = udiv i32 %newSize, 32
    %blocksr2 = add i32 %blocksr2i, 1
    store i32 %blocksr2, i32* %rbPtr, align 4
    br label %pad.done.done

  pad.done.done:
	  %return = load i32* %smallerSizePtr, align 4
	  ret i32 %return
}

define void @.extendInt(i32 %integer, i32 %size, %struct.vecType* %ptr) nounwind uwtable {
  ; calculate the number of 32-element segments required
  %temp = udiv i32 %size, 32
  ; add 1 since division rounds down
  %blocks = add i32 %temp, 1
  ; need this because calloc expects i64
  %blocks64 = zext i32 %blocks to i64

  ; allocate memory for the array
  %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
  %array = bitcast i8* %call to \<32 x i32\>*
  ; get array ptr
  %data = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
  ; plug the array in
  store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8

  ; plug in the integer values
  %1 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
  store i32 %size, i32* %1, align 4
  %2 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 1
  store i32 %blocks, i32* %2, align 4

  ; need to loop over the array and set the values
  %lc_ptr = alloca i32
  %offset_ptr = alloca i32
  store i32 0, i32* %lc_ptr, align 4
  store i32 0, i32* %offset_ptr, align 4

  br label %for.intext.begin
  for.intext.begin:
      %lc = load i32* %lc_ptr
      %offset = load i32* %offset_ptr
      %compar = icmp ugt i32 %lc, %size
      br i1 %compar, label %for.intext.done, label %for.intext.next
      for.intext.next:

      ; need to figure out which block the item is in
      %block_num = udiv i32 %offset, 32
      ; need to figure out which index in that block the item is in
      %index_block = urem i32 %offset, 32

      ; get a pointer to the list of arrays
      %ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
      ; load the list of arrays
      %array_2 = load \<32 x i32\>** %ar_ptr, align 8

      ; get the required array address
      %arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
      ; get the actual array
      %3 = load \<32 x i32\>* %arrayidx
      %insert = insertelement \<32 x i32\> %3, i32 %integer, i32 %index_block

      ;need to put it back
      store \<32 x i32\> %insert, \<32 x i32\>* %arrayidx
      %new_lc = add i32 %lc, 1
      store i32 %new_lc, i32* %lc_ptr, align 4
      %new_offset = add i32 %offset, 1
      store i32 %new_offset, i32* %offset_ptr, align 4

    br label %for.intext.begin
    for.intext.done:

  ret void
}

define void @.range(i32 %lbound, i32 %ubound, %struct.vecType* %ptr) nounwind uwtable {
    ; calculate the number of elements
    %num_elem = sub i32 %ubound, %lbound
    ; calculate the number of 32-element segments required
    %temp = udiv i32 %num_elem, 32
    ; add 1 since division rounds down
    %blocks = add i32 %temp, 1
    ; need this because calloc expects i64
    %blocks64 = zext i32 %blocks to i64
  	; allocate memory for the array
  	%call = call noalias i8* @calloc(i64 %blocks64, i64 128)
  	%array = bitcast i8* %call to \<32 x i32\>*
    ; get array ptr
    %data = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ; plug in the integer values
    %1 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
    store i32 %num_elem, i32* %1, align 4
    %2 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 1
    store i32 %blocks, i32* %2, align 4
    ; need to loop over the array and set the values
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 %lbound, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4
    br label %for.range.begin
    for.range.begin:
        %lc = load i32* %lc_ptr
        %offset = load i32* %offset_ptr
        %compar = icmp ugt i32 %lc, %ubound
        br i1 %compar, label %for.range.done, label %for.range.next
    for.range.next:
        ; need to figure out which block the item is in
        %block_num = udiv i32 %offset, 32
        ; need to figure out which index in that block the item is in
        %index_block = urem i32 %offset, 32
        ; get a pointer to the list of arrays
        %ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
        ; load the list of arrays
        %array_2 = load \<32 x i32\>** %ar_ptr, align 8
        ; get the required array address
        %arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
        ; get the actual array
        %3 = load \<32 x i32\>* %arrayidx
        %insert = insertelement \<32 x i32\> %3, i32 %lc, i32 %index_block
        ;need to put it back, not sure how yet
        store \<32 x i32\> %insert, \<32 x i32\>* %arrayidx
        ; %printer2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 11)
        %new_lc = add i32 %lc, 1
        store i32 %new_lc, i32* %lc_ptr, align 4
        %new_offset = add i32 %offset, 1
        store i32 %new_offset, i32* %offset_ptr, align 4
    br label %for.range.begin
    for.range.done:
    ret void
}


define i32 @main() nounwind uwtable {
  <container.names:{x|<init(name=(x), counters = container.counters, templates=container.inits, types=container.types)>}>
  
  <stat:{s|<s>}>

  br label %quit.label
  quit.label:
  	ret i32 0
}

declare i32 @printf(i8*, ...)
declare noalias i8* @calloc(i64, i64)
>>

declInt(name) ::= <<
;declInt
@<name> = global i32 0, align 4

>>

declVec() ::= <<
;declVec
@<name> = global %struct.vecType* null

>>

init(name, counters, templates, types) ::= <<
;init
<if(types.(name))> <initVec(name = name, counters = counters, templates = templates)>
<else> <initInt(name = name, counters = counters, templates = templates)>
<endif>

>>

initInt(name, counters, templates) ::= <<
;initInt
<templates.(name)>
store i32 %<counters.(name)>, i32* @<name>, align 4

>>

initVec(name, counters, templates) ::= <<
;initVec
<templates.(name)>
store %struct.vecType* %<counters.(name)>, %struct.vecType** @<name>

>>

if(counter, if_counter, expr_counter, expr, b) ::= <<
;if
<expr>
%<counter> = icmp ne i32 %<expr_counter>, 0
br i1 %<counter>, label %if.true<if_counter>, label %if.done<if_counter>
if.true<if_counter>:
  <b>
  br label %if.done<if_counter>
if.done<if_counter>:

>>

loop(counter, loop_counter, expr_counter, expr, b) ::= <<
;loop
br label %loop.begin<loop_counter>
loop.begin<loop_counter>:
<expr>
%<counter> = icmp eq i32 %<expr_counter>, 0
br i1 %<counter>, label %loop.done<loop_counter>, label %loop.true<loop_counter>
loop.true<loop_counter>:
  <b>
  br label %loop.begin<loop_counter>
loop.done<loop_counter>:

>>

assignInt(name, expr_counter, expr) ::= <<
;assignInt
<expr>
store i32 %<expr_counter>, i32* <name>, align 4

>>

assignVec(name, expr_counter, expr) ::= <<
;assignVec
<expr>
store %struct.vecType* %<expr_counter>, %struct.vecType** <name>

>>

printVec(counter, expr_counter, expr) ::= <<
;printVec
<expr>
%pre<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str.lbrack, i32 0, i32 0))
call void @.printVec(%struct.vecType* %<expr_counter>)
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str.rbrack, i32 0, i32 0))

>>

printInt(counter, expr_counter, expr) ::= <<
;printInt
<expr>
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %<expr_counter>)

>>

block(s) ::= <<
;blocks
<s:{x|<x>}>
>>

eqIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;eqIntInt
<lhs>
<rhs>
%pre<counter> = icmp eq i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

eqVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;eqVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

eqVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;eqVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

eqIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;eqIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

neIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;neIntInt
<lhs>
<rhs>
%pre<counter> = icmp ne i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

neVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;neVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %eq<counter>, i32 %smSize<counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)

>>

neVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;neVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %eq<counter>, i32 %size<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)


>>

neIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;neIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %eq<counter>, i32 %size<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)

>>

ltIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;ltIntInt
<lhs>
<rhs>
%pre<counter> = icmp ult i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

ltVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;ltVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

ltVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;ltVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

ltIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;ltIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

gtIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;gtIntInt
<lhs>
<rhs>
%pre<counter> = icmp ugt i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

gtVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;gtVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %<lhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

gtVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;gtVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %extended<rhs_counter>, %struct.vecType* %<lhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

gtIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;gtIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

addIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;addIntInt
<lhs>
<rhs>
%<counter> = add i32 %<lhs_counter>, %<rhs_counter>

>>

addVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;addVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.indexVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

addVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;addVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.addVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

addIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;addIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.addVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>)

>>

subIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;subIntInt
<lhs>
<rhs>
%<counter> = sub i32 %<lhs_counter>, %<rhs_counter>

>>

subVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;subVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

subVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;subVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

subIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;subIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;divVecVec
<lhs>
<rhs>
%rp<counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%lp<counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%r<counter> = load i32* %rp<counter>, align 4
%l<counter> = load i32* %lp<counter>, align 4
%smSize2<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 1)
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;divVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

divIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;divIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

mulIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;mulIntInt
<lhs>
<rhs>
%<counter> = mul i32 %<lhs_counter>, %<rhs_counter>

>>

mulVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;mulVecVec
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

mulVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;mulVecInt
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

mulIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;mulIntVec
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;divIntInt
<lhs>
<rhs>
%<counter> = udiv i32 %<lhs_counter>, %<rhs_counter>

>>

range(c1, c2, rc, lhs_counter, lhs, rhs_counter, rhs) ::= <<
;range
<lhs>
<rhs>
%<c1> = icmp ule i32 %<lhs_counter>, %<rhs_counter>
br i1 %<c1>, label %range.valid<rc>, label %range.invalid<rc>
range.valid<rc>:
    %<c2> = alloca %struct.vecType, align 8
	call void @.range(i32 %<lhs_counter>, i32 %<rhs_counter>, %struct.vecType* %<c2>)
	br label %range.done<rc>
range.invalid<rc>:
	%rerror<rc> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([54 x i8]* @.str.rerror, i32 0, i32 0))
	br label %quit.label
range.done<rc>:

>>

generator(counter, var, d_counter, d, exp_counter, exp, flag, fgc) ::= <<
;generator
%<var><fgc> = alloca %struct.vecType*, align 8
<d>
store %struct.vecType* %<d_counter>, %struct.vecType** %<var><fgc>
<exp>

<flag>%<counter> = alloca %struct.vecType, align 8
<flag>%sgptr<counter> = getelementptr inbounds %struct.vecType* %<d_counter>, i32 0, i32 0
<flag>%sgt<counter> = load i32* %sgptr<counter>, align 4
<flag>call void @.extendInt(i32 %<exp_counter>, i32 %sgt<counter>, %struct.vecType* %<counter>)

>>


filter(counter, var, d_counter, d, exp_counter, exp, fgc) ::= <<
;filter
<d>
%<var><fgc> = alloca i32, align 4
%fnptr<counter> = getelementptr inbounds %struct.vecType* %<d_counter>, i32 0, i32 0
%fsptr<counter> = getelementptr inbounds %struct.vecType* %<d_counter>, i32 0, i32 1
%fn<counter> = load i32* %fnptr<counter>, align 4
%fs<counter> = load i32* %fsptr<counter>, align 4
%fs64<counter> = sext i32 %fs<counter> to i64
%call<counter> = call noalias i8* @calloc(i64 %fs64<counter>, i64 128)
%ar<counter> = bitcast i8* %call<counter> to \<32 x i32\>*
%lcp<counter> = alloca i32, align 4
%ncp<counter> = alloca i32, align 4
store i32 0, i32* %lcp<counter>, align 4
store i32 0, i32* %ncp<counter>, align 4
br label %filter<counter>.begin
filter<counter>.begin:
	%lc<counter> = load i32* %lcp<counter>, align 4
	%cm<counter> = icmp ule i32 %lc<counter>, %fn<counter>
	br i1 %cm<counter>, label %filter<counter>.loop, label %filter<counter>.done
filter<counter>.loop:
	%bn<counter> = udiv i32 %lc<counter>, 32
	%ib<counter> = urem i32 %lc<counter>, 32
	%ap<counter> = getelementptr inbounds %struct.vecType* %<d_counter>, i32 0, i32 2
	%as<counter> = load \<32 x i32\>** %ap<counter>
	%aip<counter> = getelementptr inbounds \<32 x i32\>* %as<counter>, i32 %bn<counter>
	%aa<counter> = load \<32 x i32\>* %aip<counter>
	%v<counter> = extractelement \<32 x i32\> %aa<counter>, i32 %ib<counter>
	store i32 %v<counter>, i32* %<var><fgc>, align 4
	<exp>
	%c2<counter> = icmp ugt i32 %<exp_counter>, 0
	br i1 %c2<counter>, label %filter<counter>.add, label %filter<counter>.next
filter<counter>.add:
	%nc<counter> = load i32* %ncp<counter>, align 4
	%abn<counter> = udiv i32 %nc<counter>, 32
	%aib<counter> = urem i32 %nc<counter>, 32
	%aaip<counter> = getelementptr inbounds \<32 x i32\>* %ar<counter>, i32 %abn<counter>
	%aaa<counter> = load \<32 x i32\>* %aaip<counter>
	%ins<counter> = insertelement \<32 x i32\> %aaa<counter>, i32 %v<counter>, i32 %aib<counter>
	store \<32 x i32\> %ins<counter>, \<32 x i32\>* %aaip<counter>
	%nnc<counter> = add i32 %nc<counter>, 1
	store i32 %nnc<counter>, i32* %ncp<counter>, align 4
	br label %filter<counter>.next
filter<counter>.next:
	%nlc<counter> = add i32 %lc<counter>, 1
	store i32 %nlc<counter>, i32* %lcp<counter>, align 4
	br label %filter<counter>.begin
filter<counter>.done:
	%<counter> = alloca %struct.vecType, align 8
	%nfnptr<counter> = getelementptr inbounds %struct.vecType* %<counter>, i32 0, i32 0
	%nfsptr<counter> = getelementptr inbounds %struct.vecType* %<counter>, i32 0, i32 1
	%ndptr<counter> = getelementptr inbounds %struct.vecType* %<counter>, i32 0, i32 2
	%resultingsize<counter> = sub i32 %nnc<counter>, 1
	store i32 %resultingsize<counter>, i32* %nfnptr<counter>, align 4
	%nnca<counter> = add i32 %nnc<counter>, 1
	%nfsa<counter> = udiv i32 %nnca<counter>, 32
	%nfs<counter> = add i32 %nfsa<counter>, 1
	store i32 %nfs<counter>, i32* %nfsptr<counter>, align 4
	store \<32 x i32\>* %ar<counter>, \<32 x i32\>** %ndptr<counter>, align 8


>>


varnumInt(counter, name, varcounter) ::= <<
;varnumInt
%<counter> = load i32* <name><varcounter>
>>

varnumVec(counter, name, varcounter) ::= <<
;varnumVec
%<counter> = load %struct.vecType** <name><varcounter>
>>

integer(counter, value) ::= <<
;integer
%<counter> = add i32 <value>, 0
>>

write(input) ::= <<
;write
<input>
>>
