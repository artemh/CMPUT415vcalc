group llvm;

program(filename, container, decl, stat) ::= <<
; ModuleID = '<filename>'

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; This prints integer %d followed by \n followed by string termination symbol
@.str.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.lbrack = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.rbrack = private unnamed_addr constant [3 x i8] c" ]\00", align 1
<decl:{d|<d>}>

define i32 @main() nounwind uwtable {
  <container.intNames:{x|<initInt(name=(x), counters = container.counters, templates=container.inits)>}>
  <container.vecNames:{x|<initVec(name=(x), counters = container.counters, templates=container.inits)>}>
  <stat:{s|<s>}>

  ret i32 0
}

declare i32 @printf(i8*, ...)

>>

declInt(name) ::= <<
@<name> = global i32 0, align 4

>>

initInt(name, counters, templates) ::= <<
<templates.(name)>
store i32 %<counters.(name)>, i32* @<name>, align 4

>>

print(counter, expr_counter, expr) ::= <<
<expr>
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %<expr_counter>)

>>

addIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = add i32 %<lhs_counter>, %<rhs_counter>

>>

subIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = sub i32 %<lhs_counter>, %<rhs_counter>

>>

mulIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = mul i32 %<lhs_counter>, %<rhs_counter>

>>

divIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = udiv i32 %<lhs_counter>, %<rhs_counter>

>>

varnum(counter, name) ::= <<
%<counter> = load i32* <name>
>>

integer(counter, value) ::= <<
%<counter> = add i32 <value>, 0
>>
