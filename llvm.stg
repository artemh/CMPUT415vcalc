group llvm;

program(container, decl, stat) ::= <<
; ModuleID = '<filename()>'

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.vecType = type { i32, i32, \<32 x i32\>* }

; This prints integer %d followed by \n followed by string termination symbol
@.str.int = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.int.raw = private unnamed_addr constant [4 x i8] c"%d\20\00", align 1
@.str.lbrack = private unnamed_addr constant [3 x i8] c"[ \00", align 1
@.str.rbrack = private unnamed_addr constant [3 x i8] c"]\0A\00", align 1
@.str.rerror = private unnamed_addr constant [54 x i8] c"Range lower bound must be less than the upper bound.\0A\00", align 1
<decl:{d|<d>}>


define void @.printVec(%struct.vecType* %ptr) nounwind uwtable {
	%print_num_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
	%print_num = load i32* %print_num_ptr, align 4

	; need to loop over the array and print the values
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 0, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4

    br label %print.for.range.begin
	print.for.range.begin:
	%lc = load i32* %lc_ptr
	%offset = load i32* %offset_ptr
	%compar = icmp ugt i32 %lc, %print_num
	br i1 %compar, label %print.for.range.done, label %print.for.range.next
	print.for.range.next:
	; get a pointer to the list of arrays
	%ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
	; load the list of arrays
	%array_2 = load \<32 x i32\>** %ar_ptr, align 8
	; need to figure out which block the item is in
	%block_num = udiv i32 %offset, 32
	; need to figure out which index in that block the item is in
	%index_block = urem i32 %offset, 32
	%arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
	%1 = load \<32 x i32\>* %arrayidx
	%value = extractelement \<32 x i32\> %1, i32 %index_block
	%printerVec3 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int.raw, i32 0, i32 0), i32 %value)
	%new_lc = add i32 %lc, 1
	store i32 %new_lc, i32* %lc_ptr, align 4
	%new_offset = add i32 %offset, 1
	store i32 %new_offset, i32* %offset_ptr, align 4
	br label %print.for.range.begin
	print.for.range.done:
	ret void
}

define void @.mulVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
    %lc = load i32* %lc_ptra
    %compar3 = icmp slt i32 %lc, %Size
    br i1 %compar3, label %add.loop, label %add.done

    add.loop:
    ;perform subtraction
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
    %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
    %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

    %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
    %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

    %vector_result = mul nsw \<32 x i32\> %vector_lhs, %vector_rhs

    store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptra, align 4
    br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.subVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
    %lc = load i32* %lc_ptra
    %compar3 = icmp slt i32 %lc, %Size
    br i1 %compar3, label %add.loop, label %add.done

    add.loop:
    ;perform subtraction
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
    %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
    %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

    %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
    %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

    %vector_result = sub nsw \<32 x i32\> %vector_lhs, %vector_rhs

    store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptra, align 4
    br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.divVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
    %lc = load i32* %lc_ptra
    %compar3 = icmp slt i32 %lc, %Size
    br i1 %compar3, label %add.loop, label %add.done

    add.loop:
    ;perform subtraction
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
    %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
    %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

    %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
    %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

    %vector_result = sdiv \<32 x i32\> %vector_lhs, %vector_rhs

    store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptra, align 4
    br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

; This function assumes same size
define void @.addVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result) nounwind uwtable {
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over Size number of blocks and add
    %lc_ptra = alloca i32
    store i32 0, i32* %lc_ptra, align 4

    br label %add.loop.begin
    add.loop.begin:
    %lc = load i32* %lc_ptra
    %compar3 = icmp slt i32 %lc, %Size
    br i1 %compar3, label %add.loop, label %add.done

    add.loop:
    ;perform addition
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    %vector_lhs_idx = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %lc
    %vector_rhs_idx = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %lc
    %result_idx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc

    %vector_lhs = load \<32 x i32\>* %vector_lhs_idx, align 8
    %vector_rhs = load \<32 x i32\>* %vector_rhs_idx, align 8

    %vector_result = add \<32 x i32\> %vector_lhs, %vector_rhs

    store \<32 x i32\> %vector_result, \<32 x i32\>* %result_idx

    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptra, align 4
    br label %add.loop.begin

    add.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.lessVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result, i32 %numOps) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over number of elements and compare
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %eq.loop.begin

    eq.loop.begin:
    %lc = load i32* %lc_ptr
    %compar3 = icmp sle i32 %lc, %numOps
    br i1 %compar3, label %eq.loop, label %eq.done

    eq.loop:
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    ; need to get block number which to load
    %blocknum = udiv i32 %lc, 32
    %index = urem i32 %lc, 32

    ; need to compare indeces and set corresponding result element accordingly
    %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %blocknum
    %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %blocknum
    %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum

    %arl = load \<32 x i32\>* %arrayidxl
    %arr = load \<32 x i32\>* %arrayidxr
    %arres = load \<32 x i32\>* %resultidx

    %valuel = extractelement \<32 x i32\> %arl, i32 %index
    %valuer = extractelement \<32 x i32\> %arr, i32 %index
    ; compare
    %eqals = icmp slt i32 %valuel, %valuer
    br i1 %eqals, label %eq.yes, label %eq.no

    eq.yes:
    ; working with %arres, plug in the 1 into arres, plug the array back in
    %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
    store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
    br label %eq.next

    eq.no:
    ; working with %arres, plug in the 0 into arres, plug the array back in
    %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
    store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
    br label %eq.next
    eq.next:

    ;increment lc
    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptr, align 4
    br label %eq.loop.begin

    eq.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}


define void @.equalsVec(%struct.vecType* %lhs, %struct.vecType* %rhs, %struct.vecType* %result, i32 %numOps) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*

    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4

    ; now loop over number of elements and compare
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %eq.loop.begin

    eq.loop.begin:
    %lc = load i32* %lc_ptr
    %compar3 = icmp sle i32 %lc, %numOps
    br i1 %compar3, label %eq.loop, label %eq.done

    eq.loop:
    %ar_ptr_lhs = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    %ar_ptr_rhs = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_lhs = load \<32 x i32\>** %ar_ptr_lhs, align 8
    %array_rhs = load \<32 x i32\>** %ar_ptr_rhs, align 8

    ; need to get block number which to load
    %blocknum = udiv i32 %lc, 32
    %index = urem i32 %lc, 32

    ; need to compare indeces and set corresponding result element accordingly
    %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_lhs, i32 %blocknum
    %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_rhs, i32 %blocknum
    %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum

    %arl = load \<32 x i32\>* %arrayidxl
    %arr = load \<32 x i32\>* %arrayidxr
    %arres = load \<32 x i32\>* %resultidx

    %valuel = extractelement \<32 x i32\> %arl, i32 %index
    %valuer = extractelement \<32 x i32\> %arr, i32 %index
    ; compare
    %eqals = icmp eq i32 %valuel, %valuer
    br i1 %eqals, label %eq.yes, label %eq.no

    eq.yes:
    ; working with %arres, plug in the 1 into arres, plug the array back in
    %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
    store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
    br label %eq.next

    eq.no:
    ; working with %arres, plug in the 0 into arres, plug the array back in
    %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
    store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
    br label %eq.next
    eq.next:

    ;increment lc
    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptr, align 4
    br label %eq.loop.begin

    eq.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define void @.flip(%struct.vecType* %source, %struct.vecType* %result) nounwind uwtable {
    %numPtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 0
    %num = load i32* %numPtr, align 4
    %SizePtr = getelementptr inbounds %struct.vecType* %source, i32 0, i32 1
    %Size = load i32* %SizePtr, align 4

    ; need this because calloc expects i64
    %blocks64 = sext i32 %Size to i64
    ; allocate memory for the array
    %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %array = bitcast i8* %call to \<32 x i32\>*
    
    ; set integer values
    %newNumPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 0
    store i32 %num, i32* %newNumPtr, align 4
    %newBlockPtr = getelementptr inbounds %struct.vecType* %result, i32 0, i32 1
    store i32 %Size, i32* %newBlockPtr, align 4
    
    ; now loop over number of elements and flip
    %lc_ptr = alloca i32, align 4
    store i32 0, i32* %lc_ptr, align 4

    br label %flip.loop.begin
    
    flip.loop.begin:
    %lc = load i32* %lc_ptr
    %compar = icmp sle i32 %lc, %num
    br i1 %compar, label %flip.loop, label %flip.done
    
    flip.loop:
    %ar_ptr_source = getelementptr inbounds %struct.vecType* %source, i32 0, i32 2
    %array_source = load \<32 x i32\>** %ar_ptr_source, align 8
    
    ; need to get block number which to load
    %blocknum = udiv i32 %lc, 32
    %index = urem i32 %lc, 32
    
    %arrayidxl = getelementptr inbounds \<32 x i32\>* %array_source, i32 %blocknum
    %resultidx = getelementptr inbounds \<32 x i32\>* %array, i32 %blocknum
    
    %arsource = load \<32 x i32\>* %arrayidxl
    %arres = load \<32 x i32\>* %resultidx

    %valuesource = extractelement \<32 x i32\> %arsource, i32 %index
    ; compare
    %eqals = icmp eq i32 %valuesource, 0
    br i1 %eqals, label %flip.yes, label %flip.no
    
    flip.yes:
    ; working with %arres, plug in the 1 into arres, plug the array back in
    %insert1 = insertelement \<32 x i32\> %arres, i32 1, i32 %index
    store \<32 x i32\> %insert1, \<32 x i32\>* %resultidx
    br label %flip.next
    
    flip.no:
    ; working with %arres, plug in the 0 into arres, plug the array back in
    %insert0 = insertelement \<32 x i32\> %arres, i32 0, i32 %index
    store \<32 x i32\> %insert0, \<32 x i32\>* %resultidx
    br label %flip.next
    flip.next:
    
    ;increment lc
    %newlc = add i32 %lc, 1
    store i32 %newlc, i32* %lc_ptr, align 4
    br label %flip.loop.begin
    
    flip.done:
    ; plug in the array into the new struct
    %data = getelementptr inbounds %struct.vecType* %result, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ret void
}

define i32 @.padVec(%struct.vecType* %lhs, %struct.vecType* %rhs, i1 %flag) nounwind uwtable {
  %lhsSizePtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 1
  %rhsSizePtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 1
  %lhsSize = load i32* %lhsSizePtr, align 4
  %rhsSize = load i32* %rhsSizePtr, align 4
  %lhsNumPtr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 0
  %rhsNumPtr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 0
  %lhsNum = load i32* %lhsNumPtr, align 4
  %rhsNum = load i32* %rhsNumPtr, align 4
  
  %smallerSizePtr = alloca i32
  %denomSizePtr = alloca i32
  store i32 %rhsNum, i32* %denomSizePtr, align 4
  
  ; need to know which one is bigger
  %compar = icmp slt i32 %lhsNum, %rhsNum
  br i1 %compar, label %pad.lhs, label %pad.rhs

  pad.lhs:
		store i32 %lhsNum, i32* %smallerSizePtr, align 4
		%blocks64 = sext i32 %rhsSize to i64
		%call = call noalias i8* @calloc(i64 %blocks64, i64 128)
		%array = bitcast i8* %call to \<32 x i32\>*
		; now loop over lhs_size number of elements and copy lhs elements
		%lc_ptr = alloca i32
		store i32 0, i32* %lc_ptr, align 4
  br label %pad.lhs.begin
  pad.lhs.begin:
		%lc = load i32* %lc_ptr
		%compar3 = icmp slt i32 %lc, %lhsSize
		br i1 %compar3, label %pad.lhs.loop, label %pad.lhs.done
  pad.lhs.loop:
		%ar_ptr = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
		%array_2 = load \<32 x i32\>** %ar_ptr, align 8
		%arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %lc
		%newarrayidx = getelementptr inbounds \<32 x i32\>* %array, i32 %lc
		%array_old = load \<32 x i32\>* %arrayidx, align 8
		store \<32 x i32\> %array_old, \<32 x i32\>* %newarrayidx
		%newlc = add i32 %lc, 1
		store i32 %newlc, i32* %lc_ptr, align 4
		br label %pad.lhs.begin   
  pad.lhs.done:
    %data = getelementptr inbounds %struct.vecType* %lhs, i32 0, i32 2
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ; Set integer values
	  %load0 = load i32* %rhsNumPtr, align 4
	  store i32 %load0, i32* %lhsNumPtr, align 4
	  %load1 = load i32* %rhsSizePtr, align 4
	  store i32 %load1, i32* %lhsSizePtr, align 4
	  br label %pad.done
  
  pad.rhs:
    store i32 %rhsNum, i32* %smallerSizePtr, align 4
    %blocks64r = sext i32 %lhsSize to i64
    %callr = call noalias i8* @calloc(i64 %blocks64, i64 128)
    %arrayr = bitcast i8* %call to \<32 x i32\>*
    ; now loop over lhs_size number of elements and copy lhs elements
    %lc_ptrr = alloca i32
    store i32 0, i32* %lc_ptrr, align 4
    br label %pad.rhs.begin
  pad.rhs.begin:
    %lcr = load i32* %lc_ptrr
    %compar3r = icmp slt i32 %lcr, %rhsSize
    br i1 %compar3r, label %pad.lhs.loop, label %pad.lhs.done
  pad.rhs.loop:
    %ar_ptrr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %array_2r = load \<32 x i32\>** %ar_ptrr, align 8
    %arrayidxr = getelementptr inbounds \<32 x i32\>* %array_2r, i32 %lcr
    %newarrayidxr = getelementptr inbounds \<32 x i32\>* %arrayr, i32 %lcr
    %array_oldr = load \<32 x i32\>* %arrayidxr, align 8
    store \<32 x i32\> %array_oldr, \<32 x i32\>* %newarrayidxr
    %newlcr = add i32 %lcr, 1
    store i32 %newlcr, i32* %lc_ptrr, align 4
    br label %pad.rhs.begin     
  pad.rhs.done:  
    %datar = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    store \<32 x i32\>* %arrayr, \<32 x i32\>** %datar, align 8
    ; Set integer values
    %load0r = load i32* %lhsNumPtr, align 4
    store i32 %load0r, i32* %rhsNumPtr, align 4
    %load1r = load i32* %lhsSizePtr, align 4
    store i32 %load1r, i32* %rhsSizePtr, align 4
    br label %pad.done
    
  pad.done:
    br i1 %flag, label %pad.ones, label %pad.done.done
  pad.ones:   
	  %denum_num_ptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 0
	  %denum_blk_ptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 1
	  %denum_num = load i32* %denum_num_ptr, align 4
	  %denum_blk = load i32* %denum_blk_ptr, align 4
	  
	  %loopStarti = load i32* %denomSizePtr, align 4
	  %loopStart = sub i32 %loopStarti, 1
    %loopEnd = mul i32 %denum_blk, 32
    
    %d_lc_ptr = alloca i32, align 4
    store i32 %loopStart, i32* %d_lc_ptr, align 4
    
    %denumdataptr = getelementptr inbounds %struct.vecType* %rhs, i32 0, i32 2
    %denumdata = load \<32 x i32\>** %denumdataptr, align 8
    
    br label %pad.ones.loop
  pad.ones.loop:
    %d_lc = load i32* %d_lc_ptr
    %dcmp = icmp ult i32 %d_lc, %loopEnd
    br i1 %dcmp, label %pad.ones.next, label %pad.ones.done
  pad.ones.next:
    %dblock_index = udiv i32 %d_lc, 32
    %delem_index = urem i32 %d_lc, 32
    %denumarrayptr = getelementptr inbounds \<32 x i32\>* %denumdata, i32 %dblock_index
    
    %denumarray = load \<32 x i32\>* %denumarrayptr, align 8
    %denuminsert = insertelement \<32 x i32\> %denumarray, i32 1, i32 %delem_index
    store \<32 x i32\> %denuminsert, \<32 x i32\>* %denumarrayptr
  
    %new_d_lc = add i32 %d_lc, 1
    store i32 %new_d_lc, i32* %d_lc_ptr, align 4
    br label %pad.ones.loop
  pad.ones.done:
  
    br label %pad.done.done
  pad.done.done:
	  %return = load i32* %smallerSizePtr, align 4
	  ret i32 %return
}  
  

define void @.extendInt(i32 %integer, i32 %size_i, %struct.vecType* %ptr) nounwind uwtable {
  %size = sub i32 %size_i, 1
  ; calculate the number of 32-element segments required
  %temp = udiv i32 %size, 32
  ; add 1 since division rounds down
  %blocks = add i32 %temp, 1
  ; need this because calloc expects i64
  %blocks64 = zext i32 %blocks to i64

  ; allocate memory for the array
  %call = call noalias i8* @calloc(i64 %blocks64, i64 128)
  %array = bitcast i8* %call to \<32 x i32\>*
  ; get array ptr
  %data = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
  ; plug the array in
  store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8

  ; plug in the integer values
  %1 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
  store i32 %size, i32* %1, align 4
  %2 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 1
  store i32 %blocks, i32* %2, align 4

  ; need to loop over the array and set the values
  %lc_ptr = alloca i32
  %offset_ptr = alloca i32
  store i32 0, i32* %lc_ptr, align 4
  store i32 0, i32* %offset_ptr, align 4

  br label %for.intext.begin
  for.intext.begin:
      %lc = load i32* %lc_ptr
      %offset = load i32* %offset_ptr

      %compar = icmp ugt i32 %lc, %size
      br i1 %compar, label %for.intext.done, label %for.intext.next
      for.intext.next:

      ; need to figure out which block the item is in
      %block_num = udiv i32 %offset, 32
      ; need to figure out which index in that block the item is in
      %index_block = urem i32 %offset, 32

      ; get a pointer to the list of arrays
      %ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
      ; load the list of arrays
      %array_2 = load \<32 x i32\>** %ar_ptr, align 8

      ; get the required array address
      %arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
      ; get the actual array
      %3 = load \<32 x i32\>* %arrayidx

      %insert = insertelement \<32 x i32\> %3, i32 %integer, i32 %index_block

      ;need to put it back
      store \<32 x i32\> %insert, \<32 x i32\>* %arrayidx

      %new_lc = add i32 %lc, 1
      store i32 %new_lc, i32* %lc_ptr, align 4
      %new_offset = add i32 %offset, 1
      store i32 %new_offset, i32* %offset_ptr, align 4

    br label %for.intext.begin
    for.intext.done:

  ret void
}

define void @.range(i32 %lbound, i32 %ubound, %struct.vecType* %ptr) nounwind uwtable {
    ; calculate the number of elements
    %num_elem = sub i32 %ubound, %lbound
    ; calculate the number of 32-element segments required
    %temp = udiv i32 %num_elem, 32
    ; add 1 since division rounds down
    %blocks = add i32 %temp, 1
    ; need this because calloc expects i64
    %blocks64 = zext i32 %blocks to i64
  	; allocate memory for the array
  	%call = call noalias i8* @calloc(i64 %blocks64, i64 128)
  	%array = bitcast i8* %call to \<32 x i32\>*
    ; get array ptr
    %data = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
    ; plug the array in
    store \<32 x i32\>* %array, \<32 x i32\>** %data, align 8
    ; plug in the integer values
    %1 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 0
    store i32 %num_elem, i32* %1, align 4
    %2 = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 1
    store i32 %blocks, i32* %2, align 4
    ; need to loop over the array and set the values
    %lc_ptr = alloca i32
    %offset_ptr = alloca i32
    store i32 %lbound, i32* %lc_ptr, align 4
    store i32 0, i32* %offset_ptr, align 4
    br label %for.range.begin
    for.range.begin:
    %lc = load i32* %lc_ptr
    %offset = load i32* %offset_ptr
    %compar = icmp ugt i32 %lc, %ubound
    br i1 %compar, label %for.range.done, label %for.range.next
    for.range.next:
    ; need to figure out which block the item is in
    %block_num = udiv i32 %offset, 32
    ; need to figure out which index in that block the item is in
    %index_block = urem i32 %offset, 32
    ; get a pointer to the list of arrays
    %ar_ptr = getelementptr inbounds %struct.vecType* %ptr, i32 0, i32 2
    ; load the list of arrays
    %array_2 = load \<32 x i32\>** %ar_ptr, align 8
    ; get the required array address
    %arrayidx = getelementptr inbounds \<32 x i32\>* %array_2, i32 %block_num
    ; get the actual array
    %3 = load \<32 x i32\>* %arrayidx
    %insert = insertelement \<32 x i32\> %3, i32 %lc, i32 %index_block
    ;need to put it back, not sure how yet
    store \<32 x i32\> %insert, \<32 x i32\>* %arrayidx
    ; %printer2 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 11)
    %new_lc = add i32 %lc, 1
    store i32 %new_lc, i32* %lc_ptr, align 4
    %new_offset = add i32 %offset, 1
    store i32 %new_offset, i32* %offset_ptr, align 4
    br label %for.range.begin
    for.range.done:
    ret void
}


define i32 @main() nounwind uwtable {
  <container.vecNames:{x|<initVec(name=(x), counters = container.counters, templates=container.inits)>}>
  <container.intNames:{x|<initInt(name=(x), counters = container.counters, templates=container.inits)>}>
  <stat:{s|<s>}>

  br label %quit.label
  quit.label:
  	ret i32 0
}

declare i32 @printf(i8*, ...)
declare noalias i8* @calloc(i64, i64)
>>

declInt(name) ::= <<
@<name> = global i32 0, align 4

>>

declVec() ::= <<
@<name> = global %struct.vecType* null

>>

initInt(name, counters, templates) ::= <<
<templates.(name)>
store i32 %<counters.(name)>, i32* @<name>, align 4

>>

initVec(name, counters, templates) ::= <<
<templates.(name)>
store %struct.vecType* %<counters.(name)>, %struct.vecType** @<name>

>>

if(counter, if_counter, expr_counter, expr, b) ::= <<
<expr>
%<counter> = icmp ne i32 %<expr_counter>, 0
br i1 %<counter>, label %if.true<if_counter>, label %if.done<if_counter>
if.true<if_counter>:
  <b>
  br label %if.done<if_counter>
if.done<if_counter>:

>>

loop(counter, loop_counter, expr_counter, expr, b) ::= <<
br label %loop.begin<loop_counter>
loop.begin<loop_counter>:
<expr>
%<counter> = icmp eq i32 %<expr_counter>, 0
br i1 %<counter>, label %loop.done<loop_counter>, label %loop.true<loop_counter>
loop.true<loop_counter>:
  <b>
  br label %loop.begin<loop_counter>
loop.done<loop_counter>:

>>

assignInt(name, expr_counter, expr) ::= <<
<expr>
store i32 %<expr_counter>, i32* <name>, align 4

>>

assignVec(name, expr_counter, expr) ::= <<
<expr>
store %struct.vecType* %<expr_counter>, %struct.vecType** <name>

>>

printVec(counter, expr_counter, expr) ::= <<
<expr>
%pre<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str.lbrack, i32 0, i32 0))
call void @.printVec(%struct.vecType* %<expr_counter>)
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str.rbrack, i32 0, i32 0))

>>

printInt(counter, expr_counter, expr) ::= <<
<expr>
%<counter> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str.int, i32 0, i32 0), i32 %<expr_counter>)

>>

block(s) ::= <<
<s:{x|<x>}>
>>

eqIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%pre<counter> = icmp eq i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

eqVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

eqVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

eqIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

neIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%pre<counter> = icmp ne i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

neVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %eq<counter>, i32 %smSize<counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)

>>

neVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %eq<counter>, i32 %size<lhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)


>>

neIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%eq<counter> = alloca %struct.vecType, align 8
call void @.equalsVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %eq<counter>, i32 %size<rhs_counter>)
%<counter> = alloca %struct.vecType, align 8
call void @.flip(%struct.vecType* %eq<counter>, %struct.vecType* %<counter>)

>>

ltIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%pre<counter> = icmp ult i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

ltVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

ltVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

ltIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

gtIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%pre<counter> = icmp ugt i32 %<lhs_counter>, %<rhs_counter>
%<counter> = zext i1 %pre<counter> to i32

>>

gtVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %<lhs_counter>, %struct.vecType* %<counter>, i32 %smSize<counter>)

>>

gtVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %extended<rhs_counter>, %struct.vecType* %<lhs_counter>, %struct.vecType* %<counter>, i32 %size<lhs_counter>)

>>

gtIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.lessVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>, i32 %size<rhs_counter>)

>>

addIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = add i32 %<lhs_counter>, %<rhs_counter>

>>

addVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.addVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

addVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.addVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

addIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.addVec(%struct.vecType* %<rhs_counter>, %struct.vecType* %extended<lhs_counter>, %struct.vecType* %<counter>)

>>

subIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = sub i32 %<lhs_counter>, %<rhs_counter>

>>

subVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

subVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

subIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.subVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%rp<counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%lp<counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%r<counter> = load i32* %rp<counter>, align 4
%l<counter> = load i32* %lp<counter>, align 4
%dcmp<counter> = icmp ult i32 %l<counter>, %r<counter>
br i1 %dcmp<counter>, label %div.zero<counter>, label %div.one<counter>
div.zero<counter>:
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
br label %div.done<counter>
div.one<counter>:
%smSize2<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 1)
br label %div.done<counter>
div.done<counter>:
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

divIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.divVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

mulIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = mul i32 %<lhs_counter>, %<rhs_counter>

>>

mulVecVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%smSize<counter> = call i32 @.padVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, i1 0)
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

mulVecInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<rhs_counter> = alloca %struct.vecType, align 8
; get the lhs size
%sizePtrLhs<lhs_counter> = getelementptr inbounds %struct.vecType* %<lhs_counter>, i32 0, i32 0
%size_t<lhs_counter> = load i32* %sizePtrLhs<lhs_counter>, align 4
%size<lhs_counter> = add i32 %size_t<lhs_counter>, 1
call void @.extendInt(i32 %<rhs_counter>, i32 %size<lhs_counter>, %struct.vecType* %extended<rhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %<lhs_counter>, %struct.vecType* %extended<rhs_counter>, %struct.vecType* %<counter>)

>>

mulIntVec(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%extended<lhs_counter> = alloca %struct.vecType, align 8
; get the rhs size
%sizePtrLhs<rhs_counter> = getelementptr inbounds %struct.vecType* %<rhs_counter>, i32 0, i32 0
%size_t<rhs_counter> = load i32* %sizePtrLhs<rhs_counter>, align 4
%size<rhs_counter> = add i32 %size_t<rhs_counter>, 1
call void @.extendInt(i32 %<lhs_counter>, i32 %size<rhs_counter>, %struct.vecType* %extended<lhs_counter>);
%<counter> = alloca %struct.vecType, align 8
call void @.mulVec(%struct.vecType* %extended<lhs_counter>, %struct.vecType* %<rhs_counter>, %struct.vecType* %<counter>)

>>

divIntInt(counter, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<counter> = udiv i32 %<lhs_counter>, %<rhs_counter>

>>

range(c1, c2, rc, lhs_counter, lhs, rhs_counter, rhs) ::= <<
<lhs>
<rhs>
%<c1> = icmp ule i32 %<lhs_counter>, %<rhs_counter>
br i1 %<c1>, label %range.valid<rc>, label %range.invalid<rc>
range.valid<rc>:
    %<c2> = alloca %struct.vecType, align 8
	call void @.range(i32 %<lhs_counter>, i32 %<rhs_counter>, %struct.vecType* %<c2>)
	br label %range.done<rc>
range.invalid<rc>:
	%rerror<rc> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([54 x i8]* @.str.rerror, i32 0, i32 0))
	br label %quit.label
range.done<rc>:

>>

varnumInt(counter, name) ::= <<
%<counter> = load i32* <name>
>>

varnumVec(counter, name) ::= <<
%<counter> = load %struct.vecType** <name>
>>

integer(counter, value) ::= <<
%<counter> = add i32 <value>, 0
>>

write(input) ::= <<
<input>
>>
